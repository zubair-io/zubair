{"ts":1373400259192,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1373400260854,"patch":[[{"diffs":[[1,"/*! Hammer.JS - v1.0.5 - 2013-04-07\n * http://eightmedia.github.com/hammer.js\n *\n * Copyright (c) 2013 Jorik Tangelder <j.tangelder@gmail.com>;\n * Licensed under the MIT license */\n\n(function(window, undefined) {\n    'use strict';\n\n/**\n * Hammer\n * use this to create instances\n * @param   {HTMLElement}   element\n * @param   {Object}        options\n * @returns {Hammer.Instance}\n * @constructor\n */\nvar Hammer = function(element, options) {\n    return new Hammer.Instance(element, options || {});\n};\n\n// default settings\nHammer.defaults = {\n    // add styles and attributes to the element to prevent the browser from doing\n    // its native behavior. this doesnt prevent the scrolling, but cancels\n    // the contextmenu, tap highlighting etc\n    // set to false to disable this\n    stop_browser_behavior: {\n    \t// this also triggers onselectstart=false for IE\n        userSelect: 'none',\n\t\t// this makes the element blocking in IE10 >, you could experiment with the value\n\t\t// see for more options this issue; https://github.com/EightMedia/hammer.js/issues/241\n        touchAction: 'none',\n\t\ttouchCallout: 'none',\n        contentZooming: 'none',\n        userDrag: 'none',\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n\n    // more settings are defined per gesture at gestures.js\n};\n\n// detect touchevents\nHammer.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;\nHammer.HAS_TOUCHEVENTS = ('ontouchstart' in window);\n\n// dont use mouseevents on mobile devices\nHammer.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\nHammer.NO_MOUSEEVENTS = Hammer.HAS_TOUCHEVENTS && navigator.userAgent.match(Hammer.MOBILE_REGEX);\n\n// eventtypes per touchevent (start, move, end)\n// are filled by Hammer.event.determineEventTypes on setup\nHammer.EVENT_TYPES = {};\n\n// direction defines\nHammer.DIRECTION_DOWN = 'down';\nHammer.DIRECTION_LEFT = 'left';\nHammer.DIRECTION_UP = 'up';\nHammer.DIRECTION_RIGHT = 'right';\n\n// pointer type\nHammer.POINTER_MOUSE = 'mouse';\nHammer.POINTER_TOUCH = 'touch';\nHammer.POINTER_PEN = 'pen';\n\n// touch event defines\nHammer.EVENT_START = 'start';\nHammer.EVENT_MOVE = 'move';\nHammer.EVENT_END = 'end';\n\n// hammer document where the base events are added at\nHammer.DOCUMENT = document;\n\n// plugins namespace\nHammer.plugins = {};\n\n// if the window events are set...\nHammer.READY = false;\n\n/**\n * setup events to detect gestures on the document\n */\nfunction setup() {\n    if(Hammer.READY) {\n        return;\n    }\n\n    // find what eventtypes we add listeners to\n    Hammer.event.determineEventTypes();\n\n    // Register all gestures inside Hammer.gestures\n    for(var name in Hammer.gestures) {\n        if(Hammer.gestures.hasOwnProperty(name)) {\n            Hammer.detection.register(Hammer.gestures[name]);\n        }\n    }\n\n    // Add touch events on the document\n    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_MOVE, Hammer.detection.detect);\n    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_END, Hammer.detection.detect);\n\n    // Hammer is ready...!\n    Hammer.READY = true;\n}\n\n/**\n * create new hammer instance\n * all methods should return the instance itself, so it is chainable.\n * @param   {HTMLElement}       element\n * @param   {Object}            [options={}]\n * @returns {Hammer.Instance}\n * @constructor\n */\nHammer.Instance = function(element, options) {\n    var self = this;\n\n    // setup HammerJS window events and register all gestures\n    // this also sets up the default options\n    setup();\n\n    this.element = element;\n\n    // start/stop detection option\n    this.enabled = true;\n\n    // merge options\n    this.options = Hammer.utils.extend(\n        Hammer.utils.extend({}, Hammer.defaults),\n        options || {});\n\n    // add some css to the element to prevent the browser from doing its native behavoir\n    if(this.options.stop_browser_behavior) {\n        Hammer.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);\n    }\n\n    // start detection on touchstart\n    Hammer.event.onTouch(element, Hammer.EVENT_START, function(ev) {\n        if(self.enabled) {\n            Hammer.detection.startDetect(self, ev);\n        }\n    });\n\n    // return instance\n    return this;\n};\n\n\nHammer.Instance.prototype = {\n    /**\n     * bind events to the instance\n     * @param   {String}      gesture\n     * @param   {Function}    handler\n     * @returns {Hammer.Instance}\n     */\n    on: function onEvent(gesture, handler){\n        var gestures = gesture.split(' ');\n        for(var t=0; t<gestures.length; t++) {\n            this.element.addEventListener(gestures[t], handler, false);\n        }\n        return this;\n    },\n\n\n    /**\n     * unbind events to the instance\n     * @param   {String}      gesture\n     * @param   {Function}    handler\n     * @returns {Hammer.Instance}\n     */\n    off: function offEvent(gesture, handler){\n        var gestures = gesture.split(' ');\n        for(var t=0; t<gestures.length; t++) {\n            this.element.removeEventListener(gestures[t], handler, false);\n        }\n        return this;\n    },\n\n\n    /**\n     * trigger gesture event\n     * @param   {String}      gesture\n     * @param   {Object}      eventData\n     * @returns {Hammer.Instance}\n     */\n    trigger: function triggerEvent(gesture, eventData){\n        // create DOM event\n        var event = Hammer.DOCUMENT.createEvent('Event');\n\t\tevent.initEvent(gesture, true, true);\n\t\tevent.gesture = eventData;\n\n        // trigger on the target if it is in the instance element,\n        // this is for event delegation tricks\n        var element = this.element;\n        if(Hammer.utils.hasParent(eventData.target, element)) {\n            element = eventData.target;\n        }\n\n        element.dispatchEvent(event);\n        return this;\n    },\n\n\n    /**\n     * enable of disable hammer.js detection\n     * @param   {Boolean}   state\n     * @returns {Hammer.Instance}\n     */\n    enable: function enable(state) {\n        this.enabled = state;\n        return this;\n    }\n};\n\n/**\n * this holds the last move event,\n * used to fix empty touchend issue\n * see the onTouch event for an explanation\n * @type {Object}\n */\nvar last_move_event = null;\n\n\n/**\n * when the mouse is hold down, this is true\n * @type {Boolean}\n */\nvar enable_detect = false;\n\n\n/**\n * when touch events have been fired, this is true\n * @type {Boolean}\n */\nvar touch_triggered = false;\n\n\nHammer.event = {\n    /**\n     * simple addEventListener\n     * @param   {HTMLElement}   element\n     * @param   {String}        type\n     * @param   {Function}      handler\n     */\n    bindDom: function(element, type, handler) {\n        var types = type.split(' ');\n        for(var t=0; t<types.length; t++) {\n            element.addEventListener(types[t], handler, false);\n        }\n    },\n\n\n    /**\n     * touch events with mouse fallback\n     * @param   {HTMLElement}   element\n     * @param   {String}        eventType        like Hammer.EVENT_MOVE\n     * @param   {Function}      handler\n     */\n    onTouch: function onTouch(element, eventType, handler) {\n\t\tvar self = this;\n\n        this.bindDom(element, Hammer.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {\n            var sourceEventType = ev.type.toLowerCase();\n\n            // onmouseup, but when touchend has been fired we do nothing.\n            // this is for touchdevices which also fire a mouseup on touchend\n            if(sourceEventType.match(/mouse/) && touch_triggered) {\n                return;\n            }\n\n            // mousebutton must be down or a touch event\n            else if( sourceEventType.match(/touch/) ||   // touch events are always on screen\n                sourceEventType.match(/pointerdown/) || // pointerevents touch\n                (sourceEventType.match(/mouse/) && ev.which === 1)   // mouse is pressed\n            ){\n                enable_detect = true;\n            }\n\n            // we are in a touch event, set the touch triggered bool to true,\n            // this for the conflicts that may occur on ios and android\n            if(sourceEventType.match(/touch|pointer/)) {\n                touch_triggered = true;\n            }\n\n            // count the total touches on the screen\n            var count_touches = 0;\n\n            // when touch has been triggered in this detection session\n            // and we are now handling a mouse event, we stop that to prevent conflicts\n            if(enable_detect) {\n                // update pointerevent\n                if(Hammer.HAS_POINTEREVENTS && eventType != Hammer.EVENT_END) {\n                    count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);\n                }\n                // touch\n                else if(sourceEventType.match(/touch/)) {\n                    count_touches = ev.touches.length;\n                }\n                // mouse\n                else if(!touch_triggered) {\n                    count_touches = sourceEventType.match(/up/) ? 0 : 1;\n                }\n\n                // if we are in a end event, but when we remove one touch and\n                // we still have enough, set eventType to move\n                if(count_touches > 0 && eventType == Hammer.EVENT_END) {\n                    eventType = Hammer.EVENT_MOVE;\n                }\n                // no touches, force the end event\n                else if(!count_touches) {\n                    eventType = Hammer.EVENT_END;\n                }\n\n                // because touchend has no touches, and we often want to use these in our gestures,\n                // we send the last move event as our eventData in touchend\n                if(!count_touches && last_move_event !== null) {\n                    ev = last_move_event;\n                }\n                // store the last move event\n                else {\n                    last_move_event = ev;\n                }\n\n                // trigger the handler\n                handler.call(Hammer.detection, self.collectEventData(element, eventType, ev));\n\n                // remove pointerevent from list\n                if(Hammer.HAS_POINTEREVENTS && eventType == Hammer.EVENT_END) {\n                    count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);\n                }\n            }\n\n            //debug(sourceEventType +\" \"+ eventType);\n\n            // on the end we reset everything\n            if(!count_touches) {\n                last_move_event = null;\n                enable_detect = false;\n                touch_triggered = false;\n                Hammer.PointerEvent.reset();\n            }\n        });\n    },\n\n\n    /**\n     * we have different events for each device/browser\n     * determine what we need and set them in the Hammer.EVENT_TYPES constant\n     */\n    determineEventTypes: function determineEventTypes() {\n        // determine the eventtype we want to set\n        var types;\n\n        // pointerEvents magic\n        if(Hammer.HAS_POINTEREVENTS) {\n            types = Hammer.PointerEvent.getEvents();\n        }\n        // on Android, iOS, blackberry, windows mobile we dont want any mouseevents\n        else if(Hammer.NO_MOUSEEVENTS) {\n            types = [\n                'touchstart',\n                'touchmove',\n                'touchend touchcancel'];\n        }\n        // for non pointer events browsers and mixed browsers,\n        // like chrome on windows8 touch laptop\n        else {\n            types = [\n                'touchstart mousedown',\n                'touchmove mousemove',\n                'touchend touchcancel mouseup'];\n        }\n\n        Hammer.EVENT_TYPES[Hammer.EVENT_START]  = types[0];\n        Hammer.EVENT_TYPES[Hammer.EVENT_MOVE]   = types[1];\n        Hammer.EVENT_TYPES[Hammer.EVENT_END]    = types[2];\n    },\n\n\n    /**\n     * create touchlist depending on the event\n     * @param   {Object}    ev\n     * @param   {String}    eventType   used by the fakemultitouch plugin\n     */\n    getTouchList: function getTouchList(ev/*, eventType*/) {\n        // get the fake pointerEvent touchlist\n        if(Hammer.HAS_POINTEREVENTS) {\n            return Hammer.PointerEvent.getTouchList();\n        }\n        // get the touchlist\n        else if(ev.touches) {\n            return ev.touches;\n        }\n        // make fake touchlist from mouse position\n        else {\n            return [{\n                identifier: 1,\n                pageX: ev.pageX,\n                pageY: ev.pageY,\n                target: ev.target\n            }];\n        }\n    },\n\n\n    /**\n     * collect event data for Hammer js\n     * @param   {HTMLElement}   element\n     * @param   {String}        eventType        like Hammer.EVENT_MOVE\n     * @param   {Object}        eventData\n     */\n    collectEventData: function collectEventData(element, eventType, ev) {\n        var touches = this.getTouchList(ev, eventType);\n\n        // find out pointerType\n        var pointerType = Hammer.POINTER_TOUCH;\n        if(ev.type.match(/mouse/) || Hammer.PointerEvent.matchType(Hammer.POINTER_MOUSE, ev)) {\n            pointerType = Hammer.POINTER_MOUSE;\n        }\n\n        return {\n            center      : Hammer.utils.getCenter(touches),\n            timeStamp   : new Date().getTime(),\n            target      : ev.target,\n            touches     : touches,\n            eventType   : eventType,\n            pointerType : pointerType,\n            srcEvent    : ev,\n\n            /**\n             * prevent the browser default actions\n             * mostly used to disable scrolling of the browser\n             */\n            preventDefault: function() {\n                if(this.srcEvent.preventManipulation) {\n                    this.srcEvent.preventManipulation();\n                }\n\n                if(this.srcEvent.preventDefault) {\n                    this.srcEvent.preventDefault();\n                }\n            },\n\n            /**\n             * stop bubbling the event up to its parents\n             */\n            stopPropagation: function() {\n                this.srcEvent.stopPropagation();\n            },\n\n            /**\n             * immediately stop gesture detection\n             * might be useful after a swipe was detected\n             * @return {*}\n             */\n            stopDetect: function() {\n                return Hammer.detection.stopDetect();\n            }\n        };\n    }\n};\n\nHammer.PointerEvent = {\n    /**\n     * holds all pointers\n     * @type {Object}\n     */\n    pointers: {},\n\n    /**\n     * get a list of pointers\n     * @returns {Array}     touchlist\n     */\n    getTouchList: function() {\n        var self = this;\n        var touchlist = [];\n\n        // we can use forEach since pointerEvents only is in IE10\n        Object.keys(self.pointers).sort().forEach(function(id) {\n            touchlist.push(self.pointers[id]);\n        });\n        return touchlist;\n    },\n\n    /**\n     * update the position of a pointer\n     * @param   {String}   type             Hammer.EVENT_END\n     * @param   {Object}   pointerEvent\n     */\n    updatePointer: function(type, pointerEvent) {\n        if(type == Hammer.EVENT_END) {\n            this.pointers = {};\n        }\n        else {\n            pointerEvent.identifier = pointerEvent.pointerId;\n            this.pointers[pointerEvent.pointerId] = pointerEvent;\n        }\n\n        return Object.keys(this.pointers).length;\n    },\n\n    /**\n     * check if ev matches pointertype\n     * @param   {String}        pointerType     Hammer.POINTER_MOUSE\n     * @param   {PointerEvent}  ev\n     */\n    matchType: function(pointerType, ev) {\n        if(!ev.pointerType) {\n            return false;\n        }\n\n        var types = {};\n        types[Hammer.POINTER_MOUSE] = (ev.pointerType == ev.MSPOINTER_TYPE_MOUSE || ev.pointerType == Hammer.POINTER_MOUSE);\n        types[Hammer.POINTER_TOUCH] = (ev.pointerType == ev.MSPOINTER_TYPE_TOUCH || ev.pointerType == Hammer.POINTER_TOUCH);\n        types[Hammer.POINTER_PEN] = (ev.pointerType == ev.MSPOINTER_TYPE_PEN || ev.pointerType == Hammer.POINTER_PEN);\n        return types[pointerType];\n    },\n\n\n    /**\n     * get events\n     */\n    getEvents: function() {\n        return [\n            'pointerdown MSPointerDown',\n            'pointermove MSPointerMove',\n            'pointerup pointercancel MSPointerUp MSPointerCancel'\n        ];\n    },\n\n    /**\n     * reset the list\n     */\n    reset: function() {\n        this.pointers = {};\n    }\n};\n\n\nHammer.utils = {\n    /**\n     * extend method,\n     * also used for cloning when dest is an empty object\n     * @param   {Object}    dest\n     * @param   {Object}    src\n\t * @parm\t{Boolean}\tmerge\t\tdo a merge\n     * @returns {Object}    dest\n     */\n    extend: function extend(dest, src, merge) {\n        for (var key in src) {\n\t\t\tif(dest[key] !== undefined && merge) {\n\t\t\t\tcontinue;\n\t\t\t}\n            dest[key] = src[key];\n        }\n        return dest;\n    },\n\n\n    /**\n     * find if a node is in the given parent\n     * used for event delegation tricks\n     * @param   {HTMLElement}   node\n     * @param   {HTMLElement}   parent\n     * @returns {boolean}       has_parent\n     */\n    hasParent: function(node, parent) {\n        while(node){\n            if(node == parent) {\n                return true;\n            }\n            node = node.parentNode;\n        }\n        return false;\n    },\n\n\n    /**\n     * get the center of all the touches\n     * @param   {Array}     touches\n     * @returns {Object}    center\n     */\n    getCenter: function getCenter(touches) {\n        var valuesX = [], valuesY = [];\n\n        for(var t= 0,len=touches.length; t<len; t++) {\n            valuesX.push(touches[t].pageX);\n            valuesY.push(touches[t].pageY);\n        }\n\n        return {\n            pageX: ((Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2),\n            pageY: ((Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2)\n        };\n    },\n\n\n    /**\n     * calculate the velocity between two points\n     * @param   {Number}    delta_time\n     * @param   {Number}    delta_x\n     * @param   {Number}    delta_y\n     * @returns {Object}    velocity\n     */\n    getVelocity: function getVelocity(delta_time, delta_x, delta_y) {\n        return {\n            x: Math.abs(delta_x / delta_time) || 0,\n            y: Math.abs(delta_y / delta_time) || 0\n        };\n    },\n\n\n    /**\n     * calculate the angle between two coordinates\n     * @param   {Touch}     touch1\n     * @param   {Touch}     touch2\n     * @returns {Number}    angle\n     */\n    getAngle: function getAngle(touch1, touch2) {\n        var y = touch2.pageY - touch1.pageY,\n            x = touch2.pageX - touch1.pageX;\n        return Math.atan2(y, x) * 180 / Math.PI;\n    },\n\n\n    /**\n     * angle to direction define\n     * @param   {Touch}     touch1\n     * @param   {Touch}     touch2\n     * @returns {String}    direction constant, like Hammer.DIRECTION_LEFT\n     */\n    getDirection: function getDirection(touch1, touch2) {\n        var x = Math.abs(touch1.pageX - touch2.pageX),\n            y = Math.abs(touch1.pageY - touch2.pageY);\n\n        if(x >= y) {\n            return touch1.pageX - touch2.pageX > 0 ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;\n        }\n        else {\n            return touch1.pageY - touch2.pageY > 0 ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;\n        }\n    },\n\n\n    /**\n     * calculate the distance between two touches\n     * @param   {Touch}     touch1\n     * @param   {Touch}     touch2\n     * @returns {Number}    distance\n     */\n    getDistance: function getDistance(touch1, touch2) {\n        var x = touch2.pageX - touch1.pageX,\n            y = touch2.pageY - touch1.pageY;\n        return Math.sqrt((x*x) + (y*y));\n    },\n\n\n    /**\n     * calculate the scale factor between two touchLists (fingers)\n     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n     * @param   {Array}     start\n     * @param   {Array}     end\n     * @returns {Number}    scale\n     */\n    getScale: function getScale(start, end) {\n        // need two fingers...\n        if(start.length >= 2 && end.length >= 2) {\n            return this.getDistance(end[0], end[1]) /\n                this.getDistance(start[0], start[1]);\n        }\n        return 1;\n    },\n\n\n    /**\n     * calculate the rotation degrees between two touchLists (fingers)\n     * @param   {Array}     start\n     * @param   {Array}     end\n     * @returns {Number}    rotation\n     */\n    getRotation: function getRotation(start, end) {\n        // need two fingers\n        if(start.length >= 2 && end.length >= 2) {\n            return this.getAngle(end[1], end[0]) -\n                this.getAngle(start[1], start[0]);\n        }\n        return 0;\n    },\n\n\n    /**\n     * boolean if the direction is vertical\n     * @param    {String}    direction\n     * @returns  {Boolean}   is_vertical\n     */\n    isVertical: function isVertical(direction) {\n        return (direction == Hammer.DIRECTION_UP || direction == Hammer.DIRECTION_DOWN);\n    },\n\n\n    /**\n     * stop browser default behavior with css props\n     * @param   {HtmlElement}   element\n     * @param   {Object}        css_props\n     */\n    stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_props) {\n        var prop,\n            vendors = ['webkit','khtml','moz','ms','o',''];\n\n        if(!css_props || !element.style) {\n            return;\n        }\n\n        // with css properties for modern browsers\n        for(var i = 0; i < vendors.length; i++) {\n            for(var p in css_props) {\n                if(css_props.hasOwnProperty(p)) {\n                    prop = p;\n\n                    // vender prefix at the property\n                    if(vendors[i]) {\n                        prop = vendors[i] + prop.substring(0, 1).toUpperCase() + prop.substring(1);\n                    }\n\n                    // set the style\n                    element.style[prop] = css_props[p];\n                }\n            }\n        }\n\n        // also the disable onselectstart\n        if(css_props.userSelect == 'none') {\n            element.onselectstart = function() {\n                return false;\n            };\n        }\n    }\n};\n\nHammer.detection = {\n    // contains all registred Hammer.gestures in the correct order\n    gestures: [],\n\n    // data of the current Hammer.gesture detection session\n    current: null,\n\n    // the previous Hammer.gesture session data\n    // is a full clone of the previous gesture.current object\n    previous: null,\n\n    // when this becomes true, no gestures are fired\n    stopped: false,\n\n\n    /**\n     * start Hammer.gesture detection\n     * @param   {Hammer.Instance}   inst\n     * @param   {Object}            eventData\n     */\n    startDetect: function startDetect(inst, eventData) {\n        // already busy with a Hammer.gesture detection on an element\n        if(this.current) {\n            return;\n        }\n\n        this.stopped = false;\n\n        this.current = {\n            inst        : inst, // reference to HammerInstance we're working for\n            startEvent  : Hammer.utils.extend({}, eventData), // start eventData for distances, timing etc\n            lastEvent   : false, // last eventData\n            name        : '' // current gesture we're in/detected, can be 'tap', 'hold' etc\n        };\n\n        this.detect(eventData);\n    },\n\n\n    /**\n     * Hammer.gesture detection\n     * @param   {Object}    eventData\n     * @param   {Object}    eventData\n     */\n    detect: function detect(eventData) {\n        if(!this.current || this.stopped) {\n            return;\n        }\n\n        // extend event data with calculations about scale, distance etc\n        eventData = this.extendEventData(eventData);\n\n        // instance options\n        var inst_options = this.current.inst.options;\n\n        // call Hammer.gesture handlers\n        for(var g=0,len=this.gestures.length; g<len; g++) {\n            var gesture = this.gestures[g];\n\n            // only when the instance options have enabled this gesture\n            if(!this.stopped && inst_options[gesture.name] !== false) {\n                // if a handler returns false, we stop with the detection\n                if(gesture.handler.call(gesture, eventData, this.current.inst) === false) {\n                    this.stopDetect();\n                    break;\n                }\n            }\n        }\n\n        // store as previous event event\n        if(this.current) {\n            this.current.lastEvent = eventData;\n        }\n\n        // endevent, but not the last touch, so dont stop\n        if(eventData.eventType == Hammer.EVENT_END && !eventData.touches.length-1) {\n            this.stopDetect();\n        }\n\n        return eventData;\n    },\n\n\n    /**\n     * clear the Hammer.gesture vars\n     * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected\n     * to stop other Hammer.gestures from being fired\n     */\n    stopDetect: function stopDetect() {\n        // clone current data to the store as the previous gesture\n        // used for the double tap gesture, since this is an other gesture detect session\n        this.previous = Hammer.utils.extend({}, this.current);\n\n        // reset the current\n        this.current = null;\n\n        // stopped!\n        this.stopped = true;\n    },\n\n\n    /**\n     * extend eventData for Hammer.gestures\n     * @param   {Object}   ev\n     * @returns {Object}   ev\n     */\n    extendEventData: function extendEventData(ev) {\n        var startEv = this.current.startEvent;\n\n        // if the touches change, set the new touches over the startEvent touches\n        // this because touchevents don't have all the touches on touchstart, or the\n        // user must place his fingers at the EXACT same time on the screen, which is not realistic\n        // but, sometimes it happens that both fingers are touching at the EXACT same time\n        if(startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {\n            // extend 1 level deep to get the touchlist with the touch objects\n            startEv.touches = [];\n            for(var i=0,len=ev.touches.length; i<len; i++) {\n                startEv.touches.push(Hammer.utils.extend({}, ev.touches[i]));\n            }\n        }\n\n        var delta_time = ev.timeStamp - startEv.timeStamp,\n            delta_x = ev.center.pageX - startEv.center.pageX,\n            delta_y = ev.center.pageY - startEv.center.pageY,\n            velocity = Hammer.utils.getVelocity(delta_time, delta_x, delta_y);\n\n        Hammer.utils.extend(ev, {\n            deltaTime   : delta_time,\n\n            deltaX      : delta_x,\n            deltaY      : delta_y,\n\n            velocityX   : velocity.x,\n            velocityY   : velocity.y,\n\n            distance    : Hammer.utils.getDistance(startEv.center, ev.center),\n            angle       : Hammer.utils.getAngle(startEv.center, ev.center),\n            direction   : Hammer.utils.getDirection(startEv.center, ev.center),\n\n            scale       : Hammer.utils.getScale(startEv.touches, ev.touches),\n            rotation    : Hammer.utils.getRotation(startEv.touches, ev.touches),\n\n            startEvent  : startEv\n        });\n\n        return ev;\n    },\n\n\n    /**\n     * register new gesture\n     * @param   {Object}    gesture object, see gestures.js for documentation\n     * @returns {Array}     gestures\n     */\n    register: function register(gesture) {\n        // add an enable gesture options if there is no given\n        var options = gesture.defaults || {};\n        if(options[gesture.name] === undefined) {\n            options[gesture.name] = true;\n        }\n\n        // extend Hammer default options with the Hammer.gesture options\n        Hammer.utils.extend(Hammer.defaults, options, true);\n\n        // set its index\n        gesture.index = gesture.index || 1000;\n\n        // add Hammer.gesture to the list\n        this.gestures.push(gesture);\n\n        // sort the list by index\n        this.gestures.sort(function(a, b) {\n            if (a.index < b.index) {\n                return -1;\n            }\n            if (a.index > b.index) {\n                return 1;\n            }\n            return 0;\n        });\n\n        return this.gestures;\n    }\n};\n\n\nHammer.gestures = Hammer.gestures || {};\n\n/**\n * Custom gestures\n * ==============================\n *\n * Gesture object\n * --------------------\n * The object structure of a gesture:\n *\n * { name: 'mygesture',\n *   index: 1337,\n *   defaults: {\n *     mygesture_option: true\n *   }\n *   handler: function(type, ev, inst) {\n *     // trigger gesture event\n *     inst.trigger(this.name, ev);\n *   }\n * }\n\n * @param   {String}    name\n * this should be the name of the gesture, lowercase\n * it is also being used to disable/enable the gesture per instance config.\n *\n * @param   {Number}    [index=1000]\n * the index of the gesture, where it is going to be in the stack of gestures detection\n * like when you build an gesture that depends on the drag gesture, it is a good\n * idea to place it after the index of the drag gesture.\n *\n * @param   {Object}    [defaults={}]\n * the default settings of the gesture. these are added to the instance settings,\n * and can be overruled per instance. you can also add the name of the gesture,\n * but this is also added by default (and set to true).\n *\n * @param   {Function}  handler\n * this handles the gesture detection of your custom gesture and receives the\n * following arguments:\n *\n *      @param  {Object}    eventData\n *      event data containing the following properties:\n *          timeStamp   {Number}        time the event occurred\n *          target      {HTMLElement}   target element\n *          touches     {Array}         touches (fingers, pointers, mouse) on the screen\n *          pointerType {String}        kind of pointer that was used. matches Hammer.POINTER_MOUSE|TOUCH\n *          center      {Object}        center position of the touches. contains pageX and pageY\n *          deltaTime   {Number}        the total time of the touches in the screen\n *          deltaX      {Number}        the delta on x axis we haved moved\n *          deltaY      {Number}        the delta on y axis we haved moved\n *          velocityX   {Number}        the velocity on the x\n *          velocityY   {Number}        the velocity on y\n *          angle       {Number}        the angle we are moving\n *          direction   {String}        the direction we are moving. matches Hammer.DIRECTION_UP|DOWN|LEFT|RIGHT\n *          distance    {Number}        the distance we haved moved\n *          scale       {Number}        scaling of the touches, needs 2 touches\n *          rotation    {Number}        rotation of the touches, needs 2 touches *\n *          eventType   {String}        matches Hammer.EVENT_START|MOVE|END\n *          srcEvent    {Object}        the source event, like TouchStart or MouseDown *\n *          startEvent  {Object}        contains the same properties as above,\n *                                      but from the first touch. this is used to calculate\n *                                      distances, deltaTime, scaling etc\n *\n *      @param  {Hammer.Instance}    inst\n *      the instance we are doing the detection for. you can get the options from\n *      the inst.options object and trigger the gesture event by calling inst.trigger\n *\n *\n * Handle gestures\n * --------------------\n * inside the handler you can get/set Hammer.detection.current. This is the current\n * detection session. It has the following properties\n *      @param  {String}    name\n *      contains the name of the gesture we have detected. it has not a real function,\n *      only to check in other gestures if something is detected.\n *      like in the drag gesture we set it to 'drag' and in the swipe gesture we can\n *      check if the current gesture is 'drag' by accessing Hammer.detection.current.name\n *\n *      @readonly\n *      @param  {Hammer.Instance}    inst\n *      the instance we do the detection for\n *\n *      @readonly\n *      @param  {Object}    startEvent\n *      contains the properties of the first gesture detection in this session.\n *      Used for calculations about timing, distance, etc.\n *\n *      @readonly\n *      @param  {Object}    lastEvent\n *      contains all the properties of the last gesture detect in this session.\n *\n * after the gesture detection session has been completed (user has released the screen)\n * the Hammer.detection.current object is copied into Hammer.detection.previous,\n * this is usefull for gestures like doubletap, where you need to know if the\n * previous gesture was a tap\n *\n * options that have been set by the instance can be received by calling inst.options\n *\n * You can trigger a gesture event by calling inst.trigger(\"mygesture\", event).\n * The first param is the name of your gesture, the second the event argument\n *\n *\n * Register gestures\n * --------------------\n * When an gesture is added to the Hammer.gestures object, it is auto registered\n * at the setup of the first Hammer instance. You can also call Hammer.detection.register\n * manually and pass your gesture object as a param\n *\n */\n\n/**\n * Hold\n * Touch stays at the same place for x time\n * @events  hold\n */\nHammer.gestures.Hold = {\n    name: 'hold',\n    index: 10,\n    defaults: {\n        hold_timeout\t: 500,\n        hold_threshold\t: 1\n    },\n    timer: null,\n    handler: function holdGesture(ev, inst) {\n        switch(ev.eventType) {\n            case Hammer.EVENT_START:\n                // clear any running timers\n                clearTimeout(this.timer);\n\n                // set the gesture so we can check in the timeout if it still is\n                Hammer.detection.current.name = this.name;\n\n                // set timer and if after the timeout it still is hold,\n                // we trigger the hold event\n                this.timer = setTimeout(function() {\n                    if(Hammer.detection.current.name == 'hold') {\n                        inst.trigger('hold', ev);\n                    }\n                }, inst.options.hold_timeout);\n                break;\n\n            // when you move or end we clear the timer\n            case Hammer.EVENT_MOVE:\n                if(ev.distance > inst.options.hold_threshold) {\n                    clearTimeout(this.timer);\n                }\n                break;\n\n            case Hammer.EVENT_END:\n                clearTimeout(this.timer);\n                break;\n        }\n    }\n};\n\n\n/**\n * Tap/DoubleTap\n * Quick touch at a place or double at the same place\n * @events  tap, doubletap\n */\nHammer.gestures.Tap = {\n    name: 'tap',\n    index: 100,\n    defaults: {\n        tap_max_touchtime\t: 250,\n        tap_max_distance\t: 10,\n\t\ttap_always\t\t\t: true,\n        doubletap_distance\t: 20,\n        doubletap_interval\t: 300\n    },\n    handler: function tapGesture(ev, inst) {\n        if(ev.eventType == Hammer.EVENT_END) {\n            // previous gesture, for the double tap since these are two different gesture detections\n            var prev = Hammer.detection.previous,\n\t\t\t\tdid_doubletap = false;\n\n            // when the touchtime is higher then the max touch time\n            // or when the moving distance is too much\n            if(ev.deltaTime > inst.options.tap_max_touchtime ||\n                ev.distance > inst.options.tap_max_distance) {\n                return;\n            }\n\n            // check if double tap\n            if(prev && prev.name == 'tap' &&\n                (ev.timeStamp - prev.lastEvent.timeStamp) < inst.options.doubletap_interval &&\n                ev.distance < inst.options.doubletap_distance) {\n\t\t\t\tinst.trigger('doubletap', ev);\n\t\t\t\tdid_doubletap = true;\n            }\n\n\t\t\t// do a single tap\n\t\t\tif(!did_doubletap || inst.options.tap_always) {\n\t\t\t\tHammer.detection.current.name = 'tap';\n\t\t\t\tinst.trigger(Hammer.detection.current.name, ev);\n\t\t\t}\n        }\n    }\n};\n\n\n/**\n * Swipe\n * triggers swipe events when the end velocity is above the threshold\n * @events  swipe, swipeleft, swiperight, swipeup, swipedown\n */\nHammer.gestures.Swipe = {\n    name: 'swipe',\n    index: 40,\n    defaults: {\n        // set 0 for unlimited, but this can conflict with transform\n        swipe_max_touches  : 1,\n        swipe_velocity     : 0.7\n    },\n    handler: function swipeGesture(ev, inst) {\n        if(ev.eventType == Hammer.EVENT_END) {\n            // max touches\n            if(inst.options.swipe_max_touches > 0 &&\n                ev.touches.length > inst.options.swipe_max_touches) {\n                return;\n            }\n\n            // when the distance we moved is too small we skip this gesture\n            // or we can be already in dragging\n            if(ev.velocityX > inst.options.swipe_velocity ||\n                ev.velocityY > inst.options.swipe_velocity) {\n                // trigger swipe events\n                inst.trigger(this.name, ev);\n                inst.trigger(this.name + ev.direction, ev);\n            }\n        }\n    }\n};\n\n\n/**\n * Drag\n * Move with x fingers (default 1) around on the page. Blocking the scrolling when\n * moving left and right is a good practice. When all the drag events are blocking\n * you disable scrolling on that area.\n * @events  drag, drapleft, dragright, dragup, dragdown\n */\nHammer.gestures.Drag = {\n    name: 'drag',\n    index: 50,\n    defaults: {\n        drag_min_distance : 10,\n        // set 0 for unlimited, but this can conflict with transform\n        drag_max_touches  : 1,\n        // prevent default browser behavior when dragging occurs\n        // be careful with it, it makes the element a blocking element\n        // when you are using the drag gesture, it is a good practice to set this true\n        drag_block_horizontal   : false,\n        drag_block_vertical     : false,\n        // drag_lock_to_axis keeps the drag gesture on the axis that it started on,\n        // It disallows vertical directions if the initial direction was horizontal, and vice versa.\n        drag_lock_to_axis       : false,\n        // drag lock only kicks in when distance > drag_lock_min_distance\n        // This way, locking occurs only when the distance has become large enough to reliably determine the direction\n        drag_lock_min_distance : 25\n    },\n    triggered: false,\n    handler: function dragGesture(ev, inst) {\n        // current gesture isnt drag, but dragged is true\n        // this means an other gesture is busy. now call dragend\n        if(Hammer.detection.current.name != this.name && this.triggered) {\n            inst.trigger(this.name +'end', ev);\n            this.triggered = false;\n            return;\n        }\n\n        // max touches\n        if(inst.options.drag_max_touches > 0 &&\n            ev.touches.length > inst.options.drag_max_touches) {\n            return;\n        }\n\n        switch(ev.eventType) {\n            case Hammer.EVENT_START:\n                this.triggered = false;\n                break;\n\n            case Hammer.EVENT_MOVE:\n                // when the distance we moved is too small we skip this gesture\n                // or we can be already in dragging\n                if(ev.distance < inst.options.drag_min_distance &&\n                    Hammer.detection.current.name != this.name) {\n                    return;\n                }\n\n                // we are dragging!\n                Hammer.detection.current.name = this.name;\n\n                // lock drag to axis?\n                if(Hammer.detection.current.lastEvent.drag_locked_to_axis || (inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance<=ev.distance)) {\n                    ev.drag_locked_to_axis = true;\n                }\n                var last_direction = Hammer.detection.current.lastEvent.direction;\n                if(ev.drag_locked_to_axis && last_direction !== ev.direction) {\n                    // keep direction on the axis that the drag gesture started on\n                    if(Hammer.utils.isVertical(last_direction)) {\n                        ev.direction = (ev.deltaY < 0) ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;\n                    }\n                    else {\n                        ev.direction = (ev.deltaX < 0) ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;\n                    }\n                }\n\n                // first time, trigger dragstart event\n                if(!this.triggered) {\n                    inst.trigger(this.name +'start', ev);\n                    this.triggered = true;\n                }\n\n                // trigger normal event\n                inst.trigger(this.name, ev);\n\n                // direction event, like dragdown\n                inst.trigger(this.name + ev.direction, ev);\n\n                // block the browser events\n                if( (inst.options.drag_block_vertical && Hammer.utils.isVertical(ev.direction)) ||\n                    (inst.options.drag_block_horizontal && !Hammer.utils.isVertical(ev.direction))) {\n                    ev.preventDefault();\n                }\n                break;\n\n            case Hammer.EVENT_END:\n                // trigger dragend\n                if(this.triggered) {\n                    inst.trigger(this.name +'end', ev);\n                }\n\n                this.triggered = false;\n                break;\n        }\n    }\n};\n\n\n/**\n * Transform\n * User want to scale or rotate with 2 fingers\n * @events  transform, pinch, pinchin, pinchout, rotate\n */\nHammer.gestures.Transform = {\n    name: 'transform',\n    index: 45,\n    defaults: {\n        // factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1\n        transform_min_scale     : 0.01,\n        // rotation in degrees\n        transform_min_rotation  : 1,\n        // prevent default browser behavior when two touches are on the screen\n        // but it makes the element a blocking element\n        // when you are using the transform gesture, it is a good practice to set this true\n        transform_always_block  : false\n    },\n    triggered: false,\n    handler: function transformGesture(ev, inst) {\n        // current gesture isnt drag, but dragged is true\n        // this means an other gesture is busy. now call dragend\n        if(Hammer.detection.current.name != this.name && this.triggered) {\n            inst.trigger(this.name +'end', ev);\n            this.triggered = false;\n            return;\n        }\n\n        // atleast multitouch\n        if(ev.touches.length < 2) {\n            return;\n        }\n\n        // prevent default when two fingers are on the screen\n        if(inst.options.transform_always_block) {\n            ev.preventDefault();\n        }\n\n        switch(ev.eventType) {\n            case Hammer.EVENT_START:\n                this.triggered = false;\n                break;\n\n            case Hammer.EVENT_MOVE:\n                var scale_threshold = Math.abs(1-ev.scale);\n                var rotation_threshold = Math.abs(ev.rotation);\n\n                // when the distance we moved is too small we skip this gesture\n                // or we can be already in dragging\n                if(scale_threshold < inst.options.transform_min_scale &&\n                    rotation_threshold < inst.options.transform_min_rotation) {\n                    return;\n                }\n\n                // we are transforming!\n                Hammer.detection.current.name = this.name;\n\n                // first time, trigger dragstart event\n                if(!this.triggered) {\n                    inst.trigger(this.name +'start', ev);\n                    this.triggered = true;\n                }\n\n                inst.trigger(this.name, ev); // basic transform event\n\n                // trigger rotate event\n                if(rotation_threshold > inst.options.transform_min_rotation) {\n                    inst.trigger('rotate', ev);\n                }\n\n                // trigger pinch event\n                if(scale_threshold > inst.options.transform_min_scale) {\n                    inst.trigger('pinch', ev);\n                    inst.trigger('pinch'+ ((ev.scale < 1) ? 'in' : 'out'), ev);\n                }\n                break;\n\n            case Hammer.EVENT_END:\n                // trigger dragend\n                if(this.triggered) {\n                    inst.trigger(this.name +'end', ev);\n                }\n\n                this.triggered = false;\n                break;\n        }\n    }\n};\n\n\n/**\n * Touch\n * Called as first, tells the user has touched the screen\n * @events  touch\n */\nHammer.gestures.Touch = {\n    name: 'touch',\n    index: -Infinity,\n    defaults: {\n        // call preventDefault at touchstart, and makes the element blocking by\n        // disabling the scrolling of the page, but it improves gestures like\n        // transforming and dragging.\n        // be careful with using this, it can be very annoying for users to be stuck\n        // on the page\n        prevent_default: false,\n\n        // disable mouse events, so only touch (or pen!) input triggers events\n        prevent_mouseevents: false\n    },\n    handler: function touchGesture(ev, inst) {\n        if(inst.options.prevent_mouseevents && ev.pointerType == Hammer.POINTER_MOUSE) {\n            ev.stopDetect();\n            return;\n        }\n\n        if(inst.options.prevent_default) {\n            ev.preventDefault();\n        }\n\n        if(ev.eventType ==  Hammer.EVENT_START) {\n            inst.trigger(this.name, ev);\n        }\n    }\n};\n\n\n/**\n * Release\n * Called as last, tells the user has released the screen\n * @events  release\n */\nHammer.gestures.Release = {\n    name: 'release',\n    index: Infinity,\n    handler: function releaseGesture(ev, inst) {\n        if(ev.eventType ==  Hammer.EVENT_END) {\n            inst.trigger(this.name, ev);\n        }\n    }\n};\n\n// node export\nif(typeof module === 'object' && typeof module.exports === 'object'){\n    module.exports = Hammer;\n}\n// just window export\nelse {\n    window.Hammer = Hammer;\n\n    // requireJS module definition\n    if(typeof window.define === 'function' && window.define.amd) {\n        window.define('hammer', [], function() {\n            return Hammer;\n        });\n    }\n}\n})(this);\n\n(function($, undefined) {\n    'use strict';\n\n    // no jQuery or Zepto!\n    if($ === undefined) {\n        return;\n    }\n\n    /**\n     * bind dom events\n     * this overwrites addEventListener\n     * @param   {HTMLElement}   element\n     * @param   {String}        eventTypes\n     * @param   {Function}      handler\n     */\n    Hammer.event.bindDom = function(element, eventTypes, handler) {\n        $(element).on(eventTypes, function(ev) {\n            var data = ev.originalEvent || ev;\n\n            // IE pageX fix\n            if(data.pageX === undefined) {\n                data.pageX = ev.pageX;\n                data.pageY = ev.pageY;\n            }\n\n            // IE target fix\n            if(!data.target) {\n                data.target = ev.target;\n            }\n\n            // IE button fix\n            if(data.which === undefined) {\n                data.which = data.button;\n            }\n\n            // IE preventDefault\n            if(!data.preventDefault) {\n                data.preventDefault = ev.preventDefault;\n            }\n\n            // IE stopPropagation\n            if(!data.stopPropagation) {\n                data.stopPropagation = ev.stopPropagation;\n            }\n\n            handler.call(this, data);\n        });\n    };\n\n    /**\n     * the methods are called by the instance, but with the jquery plugin\n     * we use the jquery event methods instead.\n     * @this    {Hammer.Instance}\n     * @return  {jQuery}\n     */\n    Hammer.Instance.prototype.on = function(types, handler) {\n        return $(this.element).on(types, handler);\n    };\n    Hammer.Instance.prototype.off = function(types, handler) {\n        return $(this.element).off(types, handler);\n    };\n\n\n    /**\n     * trigger events\n     * this is called by the gestures to trigger an event like 'tap'\n     * @this    {Hammer.Instance}\n     * @param   {String}    gesture\n     * @param   {Object}    eventData\n     * @return  {jQuery}\n     */\n    Hammer.Instance.prototype.trigger = function(gesture, eventData){\n        var el = $(this.element);\n        if(el.has(eventData.target).length) {\n            el = $(eventData.target);\n        }\n\n        return el.trigger({\n            type: gesture,\n            gesture: eventData\n        });\n    };\n\n\n    /**\n     * jQuery plugin\n     * create instance of Hammer and watch for gestures,\n     * and when called again you can change the options\n     * @param   {Object}    [options={}]\n     * @return  {jQuery}\n     */\n    $.fn.hammer = function(options) {\n        return this.each(function() {\n            var el = $(this);\n            var inst = el.data('hammer');\n            // start new hammer instance\n            if(!inst) {\n                el.data('hammer', new Hammer(this, options || {}));\n            }\n            // change the options\n            else if(inst && options) {\n                Hammer.utils.extend(inst.options, options);\n            }\n        });\n    };\n\n})(window.jQuery || window.Zepto);\n"]],"start1":0,"start2":0,"length1":0,"length2":48725}]],"length":48725,"saved":false}
